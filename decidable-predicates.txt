-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for manipulating dependently-typed predicates.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/mstksg/decidable-predicates#readme</a>
@package decidable-predicates
@version 0.1.0.0


-- | Combinators for working with type-level predicates, along with
--   typeclasses for canonical proofs and deciding functions.
module Data.Type.Predicate

-- | A type-level predicate in Haskell. We say that the predicate <tt>P ::
--   'Predicate k'</tt> is true/satisfied by input <tt>x :: k</tt> if there
--   exists a value of type <tt>P </tt><tt> x</tt>, and that it
--   false/disproved if such a value cannot exist.
--   
--   See <a>Provable</a> and <a>Decidable</a> for more information on how
--   to use, prove and decide these predicates.
--   
--   The kind <tt>k ~&gt; <a>Type</a></tt> is the kind of "matchable"
--   type-level functions in Haskell. They are type-level functions that
--   are encoded as dummy type constructors ("defunctionalization symbols")
--   that can be decidedly "matched" on for things like typeclass
--   instances.
--   
--   There are two ways to define your own predicates:
--   
--   <ol>
--   <li>Using the predicate combinators and predicate transformers in this
--   library and the <i>singletons</i> library, which let you construct
--   pre-made predicates and sometimes create predicates from other
--   predicates.</li>
--   <li>Manually creating a data type that acts as a matchable
--   predicate.</li>
--   </ol>
--   
--   For an example of the latter, we can create the "not p" predicate,
--   which takes a predicate <tt>p</tt> as input and returns the negation
--   of the predicate:
--   
--   <pre>
--   -- First, create the data type with the kind signature you want
--   data Not :: Predicate k -&gt; Predicate k
--   
--   -- Then, write the <a>Apply</a> instance, to specify the type of the
--   -- witnesses of that predicate
--   instance Apply (Not p) a = (p @@ a) -&gt; Void
--   </pre>
--   
--   See the source of <a>Data.Type.Predicate</a> and
--   <a>Data.Type.Predicate.Logic</a> for simple examples of hand-made
--   predicates. For example, we have the always-true predicate
--   <a>Evident</a>:
--   
--   <pre>
--   data Evident :: Predicate k
--   instance Apply Evident a = Sing a
--   </pre>
--   
--   And the "and" predicate combinator:
--   
--   <pre>
--   data (&amp;&amp;&amp;) :: Predicate k -&gt; Predicate k -&gt; Predicate k
--   instance Apply (p &amp;&amp;&amp; q) a = (p @<tt> a, q </tt>@ a)
--   </pre>
--   
--   Typically it is recommended to create predicates from the supplied
--   predicate combinators (<a>TyPred</a> can be used for any type
--   constructor to turn it into a predicate, for instance) whenever
--   possible.
type Predicate k = k ~> Type

-- | A <tt><a>Wit</a> p a</tt> is a value of type <tt>p </tt><tt> a</tt>
--   --- that is, it is a proof or witness that <tt>p</tt> is satisfied for
--   <tt>a</tt>.
newtype Wit p a
Wit :: (p @@ a) -> Wit p a
[getWit] :: Wit p a -> p @@ a

-- | Convert a normal '-&gt;' type constructor into a <a>Predicate</a>.
--   
--   <pre>
--   <a>TyPred</a> :: (k -&gt; <a>Type</a>) -&gt; <a>Predicate</a> k
--   </pre>
type TyPred = (TyCon1 :: (k -> Type) -> Predicate k)

-- | The always-true predicate.
--   
--   <pre>
--   <a>Evident</a> :: <a>Predicate</a> k
--   </pre>
type Evident = (TyPred Sing :: Predicate k)

-- | <tt><a>EqualTo</a> a</tt> is a predicate that the input is equal to
--   <tt>a</tt>.
type EqualTo (a :: k) = (TyPred ((:~:) a) :: Predicate k)

-- | Convert a tradtional <tt>k ~&gt; <a>Bool</a></tt> predicate into a
--   <a>Predicate</a>.
--   
--   <pre>
--   <a>BoolPred</a> :: (k ~&gt; Bool) -&gt; Predicate k
--   </pre>
type BoolPred (p :: k ~> Bool) = (EqualTo  'True .@#@$$$ p :: Predicate k)

-- | The always-false predicate
data Impossible :: Predicate k

-- | Pre-compose a function to a predicate
--   
--   <pre>
--   <a>PMap</a> :: (k ~&gt; j) -&gt; <a>Predicate</a> j -&gt; Predicate k
--   </pre>
type PMap (f :: k ~> j) (p :: Predicate j) = (p .@#@$$$ f :: Predicate k)

-- | <tt><a>Not</a> p</tt> is the predicate that <tt>p</tt> is not true.
data Not :: Predicate k -> Predicate k

-- | Decide <tt>Not p</tt> based on decisions of <tt>p</tt>.
decideNot :: forall p a. () => Decision (p @@ a) -> Decision (Not p @@ a)

-- | A proving function for predicate <tt>p</tt>. See <a>Provable</a> for
--   more information.
type Prove p = forall a. Sing a -> p @@ a

-- | We say that <tt>p</tt> implies <tt>q</tt> (<tt>p <a>--&gt;</a> q</tt>)
--   if, given <tt>p </tt><tt> a</tt>, we can always prove <tt>q </tt><tt>
--   a</tt>.
type p --> q = forall a. Sing a -> p @@ a -> q @@ a
infixr 2 -->

-- | This is implication <a>--&gt;#</a>, but only in a specific context
--   <tt>h</tt>.
type ( p --># q ) h = forall a. Sing a -> p @@ a -> h (q @@ a)
infixr 2 -->#

-- | A typeclass for provable predicates (constructivist tautologies).
--   
--   A predicate is provable if, given any input <tt>a</tt>, you can
--   generate a proof of <tt>p </tt><tt> a</tt>. Essentially, it means that
--   a predicate is "always true".
--   
--   This typeclass associates a canonical proof function for every
--   provable predicate.
--   
--   It confers two main advatnages:
--   
--   <ol>
--   <li>The proof function for every predicate is available via the same
--   name</li>
--   <li>We can write <a>Provable</a> instances for polymorphic predicate
--   transformers (predicates parameterized on other predicates) easily, by
--   refering to <a>Provable</a> instances of the transformed
--   predicates.</li>
--   </ol>
class Provable p

-- | The canonical proving function for predicate <tt>p</tt>.
--   
--   Note that <a>prove</a> is ambiguously typed, so you <i>always</i> need
--   to call by specifying the predicate you want to prove using
--   TypeApplications syntax:
--   
--   <pre>
--   <a>prove</a> @MyPredicate
--   </pre>
prove :: Provable p => Prove p

-- | Implicatons <tt>p <a>--&gt;</a> q</tt> can be lifted "through" a
--   <a>TFunctor</a> into an <tt>f p <a>--&gt;</a> f q</tt>.
class TFunctor f
tmap :: forall p q. TFunctor f => (p --> q) -> f p --> f q

-- | Compose two implications.
compImpl :: forall p q r. () => (p --> q) -> (q --> r) -> p --> r

-- | A decision function for predicate <tt>p</tt>. See <a>Decidable</a> for
--   more information.
type Decide p = forall a. Sing a -> Decision (p @@ a)

-- | Like implication <a>--&gt;</a>, but knowing <tt>p </tt><tt> a</tt> can
--   only let us decidably prove <tt>q </tt><tt> a</tt> is true or false.
type p -?> q = forall a. Sing a -> p @@ a -> Decision (q @@ a)
infixr 2 -?>

-- | Like <a>-?&gt;</a>, but only in a specific context <tt>h</tt>.
type ( p -?># q ) h = forall a. Sing a -> p @@ a -> h (Decision (q @@ a))
infixr 2 -?>#

-- | A typeclass for decidable predicates.
--   
--   A predicate is decidable if, given any input <tt>a</tt>, you can
--   either prove or disprove <tt>p </tt><tt> a</tt>. A <tt><a>Decision</a>
--   (p </tt><tt> a)</tt> is a data type that has a branch <tt>p </tt><tt>
--   a</tt> and <tt><a>Refuted</a> (p </tt><tt> a)</tt>.
--   
--   This typeclass associates a canonical decision function for every
--   decidable predicate.
--   
--   It confers two main advatnages:
--   
--   <ol>
--   <li>The decision function for every predicate is available via the
--   same name</li>
--   <li>We can write <a>Decidable</a> instances for polymorphic predicate
--   transformers (predicates parameterized on other predicates) easily, by
--   refering to <a>Decidable</a> instances of the transformed
--   predicates.</li>
--   </ol>
class Decidable p

-- | The canonical decision function for predicate <tt>p</tt>.
--   
--   Note that <a>decide</a> is ambiguously typed, so you <i>always</i>
--   need to call by specifying the predicate you want to prove using
--   TypeApplications syntax:
--   
--   <pre>
--   <a>decide</a> @MyPredicate
--   </pre>
decide :: Decidable p => Decide p

-- | The canonical decision function for predicate <tt>p</tt>.
--   
--   Note that <a>decide</a> is ambiguously typed, so you <i>always</i>
--   need to call by specifying the predicate you want to prove using
--   TypeApplications syntax:
--   
--   <pre>
--   <a>decide</a> @MyPredicate
--   </pre>
decide :: (Decidable p, Provable p) => Decide p

-- | Implicatons <tt>p <a>-?&gt;</a> q</tt> can be lifted "through" a
--   <a>DFunctor</a> into an <tt>f p <a>-?&gt;</a> f q</tt>.
class DFunctor f
dmap :: forall p q. DFunctor f => (p -?> q) -> f p -?> f q
instance Data.Type.Predicate.Provable (Data.Type.Predicate.Not Data.Type.Predicate.Impossible)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *). Data.Type.Predicate.Decidable p => Data.Type.Predicate.Decidable (Data.Type.Predicate.Not p)
instance forall k (a :: k). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI a) => Data.Type.Predicate.Decidable (Data.Type.Predicate.EqualTo a)
instance Data.Type.Predicate.Decidable Data.Type.Predicate.Evident
instance forall k1 b6989586621679919354 (f :: b6989586621679919354 Data.Singletons.Internal.~> *) (g :: k1 Data.Singletons.Internal.~> b6989586621679919354). (Data.Type.Predicate.Decidable f, Data.Singletons.Internal.SingI g) => Data.Type.Predicate.Decidable (f Data.Singletons.Prelude.Base..@#@$$$ g)
instance Data.Type.Predicate.Decidable Data.Type.Predicate.Impossible
instance Data.Type.Predicate.Provable Data.Type.Predicate.Evident
instance forall k1 b6989586621679919354 (f :: b6989586621679919354 Data.Singletons.Internal.~> *) (g :: k1 Data.Singletons.Internal.~> b6989586621679919354). (Data.Type.Predicate.Provable f, Data.Singletons.Internal.SingI g) => Data.Type.Predicate.Provable (f Data.Singletons.Prelude.Base..@#@$$$ g)


-- | Logical and algebraic connectives for predicates, as well as common
--   logical combinators.
module Data.Type.Predicate.Logic

-- | The always-true predicate.
--   
--   <pre>
--   <a>Evident</a> :: <a>Predicate</a> k
--   </pre>
type Evident = (TyPred Sing :: Predicate k)

-- | The always-false predicate
data Impossible :: Predicate k

-- | <tt><a>Not</a> p</tt> is the predicate that <tt>p</tt> is not true.
data Not :: Predicate k -> Predicate k

-- | Decide <tt>Not p</tt> based on decisions of <tt>p</tt>.
decideNot :: forall p a. () => Decision (p @@ a) -> Decision (Not p @@ a)

-- | <tt>p <a>&amp;&amp;&amp;</a> q</tt> is a predicate that both
--   <tt>p</tt> and <tt>q</tt> are true.
data (&&&) :: Predicate k -> Predicate k -> Predicate k
infixr 3 &&&

-- | Decide <tt>p <a>&amp;&amp;&amp;</a> q</tt> based on decisions of
--   <tt>p</tt> and <tt>q</tt>.
decideAnd :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p &&& q) @@ a)

-- | <tt>p <a>|||</a> q</tt> is a predicate that either <tt>p</tt> and
--   <tt>q</tt> are true.
data (|||) :: Predicate k -> Predicate k -> Predicate k
infixr 2 |||

-- | Decide <tt>p <a>|||</a> q</tt> based on decisions of <tt>p</tt> and
--   <tt>q</tt>.
decideOr :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p ||| q) @@ a)

-- | <tt>p <a>^^^</a> q</tt> is a predicate that either <tt>p</tt> and
--   <tt>q</tt> are true, but not both.
type p ^^^ q = (p &&& Not q) ||| (Not p &&& q)

-- | Decide <tt>p <a>^^^</a> q</tt> based on decisions of <tt>p</tt> and
--   <tt>q</tt>.
decideXor :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p ^^^ q) @@ a)

-- | <tt>p ==&gt; q</tt> is true if <tt>q</tt> is provably true under the
--   condition that <tt>p</tt> is true.
data (==>) :: Predicate k -> Predicate k -> Predicate k
infixr 2 ==>

-- | If <tt>q</tt> is provable, then so is <tt>p <a>==&gt;</a> q</tt>.
--   
--   This can be used as an easy plug-in <a>Provable</a> instance for <tt>p
--   <a>==&gt;</a> q</tt> if <tt>q</tt> is <a>Provable</a>:
--   
--   <pre>
--   instance Provable (p ==&gt; MyPred) where
--       prove = proveImplies @MyPred
--   </pre>
--   
--   This instance isn't provided polymorphically because of overlapping
--   instance issues.
proveImplies :: Prove q -> Prove (p ==> q)

-- | Two-way implication, or logical equivalence
type p <==> q = p ==> q &&& q ==> p

-- | Compose two implications.
compImpl :: forall p q r. () => (p --> q) -> (q --> r) -> p --> r

-- | From <tt><a>Impossible</a> </tt><tt> a</tt>, you can prove anything.
--   Essentially a lifted version of <a>absurd</a>.
explosion :: Impossible --> p

-- | <a>Evident</a> can be proven from all predicates.
atom :: p --> Evident

-- | We cannot have both <tt>p</tt> and <tt><a>Not</a> p</tt>.
excludedMiddle :: (p &&& Not p) --> Impossible

-- | Logical double negation. Only possible if <tt>p</tt> is
--   <a>Decidable</a>.
doubleNegation :: forall p. Decidable p => Not (Not p) --> p

-- | If p implies q, then not q implies not p.
contrapositive :: (p --> q) -> Not q --> Not p

-- | Reverse direction of <a>contrapositive</a>
contrapositive' :: forall p q. Decidable q => (Not q --> Not p) -> p --> q
instance forall k1 (p :: Data.Type.Predicate.Predicate k1). Data.Type.Predicate.Decidable (Data.Type.Predicate.Impossible Data.Type.Predicate.Logic.==> p)
instance forall k1 (p :: Data.Type.Predicate.Predicate k1). Data.Type.Predicate.Provable (Data.Type.Predicate.Impossible Data.Type.Predicate.Logic.==> p)
instance forall k1 (p :: Data.Type.Predicate.Predicate k1) (q :: Data.Type.Predicate.Predicate k1). (Data.Type.Predicate.Decidable (p Data.Type.Predicate.Logic.==> q), Data.Type.Predicate.Decidable q) => Data.Type.Predicate.Decidable (Data.Type.Predicate.Not q Data.Type.Predicate.Logic.==> Data.Type.Predicate.Not p)
instance forall k1 (p :: Data.Type.Predicate.Predicate k1) (q :: Data.Type.Predicate.Predicate k1). Data.Type.Predicate.Provable (p Data.Type.Predicate.Logic.==> q) => Data.Type.Predicate.Provable (Data.Type.Predicate.Not q Data.Type.Predicate.Logic.==> Data.Type.Predicate.Not p)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *) (q :: k1 Data.Singletons.Internal.~> *). (Data.Type.Predicate.Decidable p, Data.Type.Predicate.Decidable q) => Data.Type.Predicate.Decidable (p Data.Type.Predicate.Logic.||| q)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *) (q :: k1 Data.Singletons.Internal.~> *). (Data.Type.Predicate.Provable p, Data.Type.Predicate.Provable q) => Data.Type.Predicate.Provable (p Data.Type.Predicate.Logic.||| q)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *) (q :: k1 Data.Singletons.Internal.~> *). (Data.Type.Predicate.Decidable p, Data.Type.Predicate.Decidable q) => Data.Type.Predicate.Decidable (p Data.Type.Predicate.Logic.&&& q)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *) (q :: k1 Data.Singletons.Internal.~> *). (Data.Type.Predicate.Provable p, Data.Type.Predicate.Provable q) => Data.Type.Predicate.Provable (p Data.Type.Predicate.Logic.&&& q)


-- | Combinators for working with type-level predicates, along with
--   typeclasses for canonical proofs and deciding functions.
module Data.Type.Universe

-- | A witness for membership of a given item in a type-level collection
type family Elem (f :: Type -> Type) :: f k -> k -> Type

-- | <tt><a>In</a> f as</tt> is a predicate that a given input <tt>a</tt>
--   is a member of collection <tt>as</tt>.
type In (f :: Type -> Type) (as :: f k) = TyCon1 (Elem f as)

-- | Typeclass for a type-level container that you can quantify or lift
--   type-level predicates over.
class Universe (f :: Type -> Type)

-- | <a>decideAny</a>, but providing an <a>Elem</a>.
idecideAny :: forall k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> Sing as -> Decision (Any f p @@ as)

-- | <a>decideAll</a>, but providing an <a>Elem</a>.
idecideAll :: forall k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> Sing as -> Decision (All f p @@ as)

-- | <a>genAllA</a>, but providing an <a>Elem</a>.
igenAllA :: forall k (p :: k ~> Type) (as :: f k) h. (Universe f, Applicative h) => (forall a. Elem f as a -> Sing a -> h (p @@ a)) -> Sing as -> h (All f p @@ as)

-- | Witness an item in a type-level list by providing its index.
data Index :: [k] -> k -> Type
[IZ] :: Index (a : as) a
[IS] :: Index bs a -> Index (b : bs) a

-- | Witness an item in a type-level <a>Maybe</a> by proving the
--   <a>Maybe</a> is <a>Just</a>.
data IsJust :: Maybe k -> k -> Type
[IsJust] :: IsJust ( 'Just a) a

-- | Witness an item in a type-level <tt><a>Either</a> j</tt> by proving
--   the <a>Either</a> is <a>Right</a>.
data IsRight :: Either j k -> k -> Type
[IsRight] :: IsRight ( 'Right a) a

-- | Witness an item in a type-level <a>NonEmpty</a> by either indicating
--   that it is the "head", or by providing an index in the "tail".
data NEIndex :: NonEmpty k -> k -> Type
[NEHead] :: NEIndex (a :| as) a
[NETail] :: Index as a -> NEIndex (b :| as) a

-- | Trivially witness an item in the second field of a type-level tuple.
data Snd :: (j, k) -> k -> Type
[Snd] :: Snd '(a, b) b

-- | An <tt><a>All</a> f p</tt> is a predicate testing a collection <tt>as
--   :: f a</tt> for the fact that <i>all</i> items in <tt>as</tt> satisfy
--   <tt>p</tt>. Represents the "forall" quantifier over a given universe.
--   
--   This is mostly useful for its <a>Decidable</a>, <a>Provable</a>, and
--   <a>TFunctor</a> instances, which lets you lift predicates on
--   <tt>p</tt> to predicates on <tt><a>All</a> f p</tt>.
data All f :: (k ~> Type) -> (f k ~> Type)

-- | A <tt><a>WitAll</a> p as</tt> is a witness that the predicate <tt>p
--   a</tt> is true for all items <tt>a</tt> in the type-level collection
--   <tt>as</tt>.
newtype WitAll f p (as :: f k)
WitAll :: (forall a. Elem f as a -> p @@ a) -> WitAll f p
[runWitAll] :: WitAll f p -> forall a. Elem f as a -> p @@ a

-- | An <tt><a>Any</a> f p</tt> is a predicate testing a collection <tt>as
--   :: f a</tt> for the fact that at least one item in <tt>as</tt>
--   satisfies <tt>p</tt>. Represents the "exists" quantifier over a given
--   universe.
--   
--   This is mostly useful for its <a>Decidable</a> and <a>TFunctor</a>
--   instances, which lets you lift predicates on <tt>p</tt> to predicates
--   on <tt><a>Any</a> f p</tt>.
data Any f :: (k ~> Type) -> (f k ~> Type)

-- | A <tt><a>WitAny</a> p as</tt> is a witness that, for at least one item
--   <tt>a</tt> in the type-level collection <tt>as</tt>, the predicate
--   <tt>p a</tt> is true.
data WitAny f :: (k ~> Type) -> f k -> Type
[WitAny] :: Elem f as a -> (p @@ a) -> WitAny f p as

-- | A <tt><a>None</a> f p</tt> is a predicate on a collection <tt>as</tt>
--   that no <tt>a</tt> in <tt>as</tt> satisfies predicate <tt>p</tt>.
type None f p = (Not (Any f p) :: Predicate (f k))

-- | Predicate that a given <tt>as :: f k</tt> is empty and has no items in
--   it.
type Null f = (None f Evident :: Predicate (f k))

-- | Predicate that a given <tt>as :: f k</tt> is not empty, and has at
--   least one item in it.
type NotNull f = (Any f Evident :: Predicate (f k))

-- | Lifts a predicate <tt>p</tt> on an individual <tt>a</tt> into a
--   predicate that on a collection <tt>as</tt> that is true if and only if
--   <i>any</i> item in <tt>as</tt> satisfies the original predicate.
--   
--   That is, it turns a predicate of kind <tt>k ~&gt; Type</tt> into a
--   predicate of kind <tt>f k ~&gt; Type</tt>.
--   
--   Essentially tests existential quantification.
decideAny :: forall f k (p :: k ~> Type). Universe f => Decide p -> Decide (Any f p)

-- | Lifts a predicate <tt>p</tt> on an individual <tt>a</tt> into a
--   predicate that on a collection <tt>as</tt> that is true if and only if
--   <i>all</i> items in <tt>as</tt> satisfies the original predicate.
--   
--   That is, it turns a predicate of kind <tt>k ~&gt; Type</tt> into a
--   predicate of kind <tt>f k ~&gt; Type</tt>.
--   
--   Essentially tests universal quantification.
decideAll :: forall f k (p :: k ~> Type). Universe f => Decide p -> Decide (All f p)

-- | If <tt>p a</tt> is true for all values <tt>a</tt> in <tt>as</tt> under
--   some (Applicative) context <tt>h</tt>, then you can create an
--   <tt><a>All</a> p as</tt> under that Applicative context <tt>h</tt>.
--   
--   Can be useful with <a>Identity</a> (which is basically unwrapping and
--   wrapping <a>All</a>), or with <a>Maybe</a> (which can express
--   predicates that are either provably true or not provably false).
--   
--   In practice, this can be used to iterate and traverse and sequence
--   actions over all "items" in <tt>as</tt>.
genAllA :: forall k (p :: k ~> Type) (as :: f k) h. (Universe f, Applicative h) => (forall a. Sing a -> h (p @@ a)) -> Sing as -> h (All f p @@ as)

-- | If <tt>p a</tt> is true for all values <tt>a</tt> in <tt>as</tt>, then
--   we have <tt><a>All</a> p as</tt>. Basically witnesses the definition
--   of <a>All</a>.
genAll :: forall f k (p :: k ~> Type). Universe f => Prove p -> Prove (All f p)

-- | <a>genAll</a>, but providing an <a>Elem</a>.
igenAll :: forall f k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> p @@ a) -> Sing as -> All f p @@ as

-- | A <a>foldMap</a> over all items in a collection.
foldMapUni :: forall f k (as :: f k) m. (Universe f, Monoid m) => (forall (a :: k). Sing a -> m) -> Sing as -> m

-- | <a>foldMapUni</a> but with access to the index.
ifoldMapUni :: forall f k (as :: f k) m. (Universe f, Monoid m) => (forall a. Elem f as a -> Sing a -> m) -> Sing as -> m

-- | Extract the item from the container witnessed by the <a>Elem</a>
index :: forall f as a. Universe f => Elem f as a -> Sing as -> Sing a

-- | Automatically generate a witness for a member, if possible
pickElem :: forall f k (as :: f k) a. (Universe f, SingI as, SingI a, SDecide k) => Decision (Elem f as a)
data ElemSym0 (f :: Type -> Type) :: f k ~> k ~> Type
data ElemSym1 (f :: Type -> Type) :: f k -> k ~> Type
type ElemSym2 (f :: Type -> Type) (as :: f k) (a :: k) = Elem f as a
instance forall k (as :: [k]) (a :: k). GHC.Show.Show (Data.Type.Universe.Index as a)
instance forall k (as :: GHC.Maybe.Maybe k) (a :: k). GHC.Show.Show (Data.Type.Universe.IsJust as a)
instance forall j k (as :: Data.Either.Either j k) (a :: k). GHC.Show.Show (Data.Type.Universe.IsRight as a)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k). GHC.Show.Show (Data.Type.Universe.NEIndex as a)
instance forall j k (as :: (j, k)) (a :: k). GHC.Show.Show (Data.Type.Universe.Snd as a)
instance forall j k (as :: (j, k)). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decidable (Data.Type.Predicate.TyPred (Data.Type.Universe.Snd as))
instance Data.Type.Universe.Universe ((,) j)
instance forall k (as :: GHC.Base.NonEmpty k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decidable (Data.Type.Predicate.TyPred (Data.Type.Universe.NEIndex as))
instance Data.Type.Universe.Universe GHC.Base.NonEmpty
instance forall j k (as :: Data.Either.Either j k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decidable (Data.Type.Predicate.TyPred (Data.Type.Universe.IsRight as))
instance Data.Type.Universe.Universe (Data.Either.Either j)
instance forall k (as :: GHC.Maybe.Maybe k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decidable (Data.Type.Predicate.TyPred (Data.Type.Universe.IsJust as))
instance Data.Type.Universe.Universe GHC.Maybe.Maybe
instance forall k (as :: [k]). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decidable (Data.Type.Predicate.TyPred (Data.Type.Universe.Index as))
instance Data.Type.Universe.Universe []
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Provable p) => Data.Type.Predicate.Decidable (Data.Type.Universe.NotNull f Data.Type.Predicate.Logic.==> Data.Type.Universe.Any f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Provable p) => Data.Type.Predicate.Provable (Data.Type.Universe.NotNull f Data.Type.Predicate.Logic.==> Data.Type.Universe.Any f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decidable p) => Data.Type.Predicate.Decidable (Data.Type.Universe.Any f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decidable p) => Data.Type.Predicate.Decidable (Data.Type.Universe.All f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Provable p) => Data.Type.Predicate.Provable (Data.Type.Universe.All f p)
instance Data.Type.Universe.Universe f => Data.Type.Predicate.TFunctor (Data.Type.Universe.Any f)
instance Data.Type.Universe.Universe f => Data.Type.Predicate.TFunctor (Data.Type.Universe.All f)
instance Data.Type.Universe.Universe f => Data.Type.Predicate.DFunctor (Data.Type.Universe.All f)


-- | Higher-level predicates for quantifying predicates over universes and
--   sets.
module Data.Type.Predicate.Quantification

-- | An <tt><a>Any</a> f p</tt> is a predicate testing a collection <tt>as
--   :: f a</tt> for the fact that at least one item in <tt>as</tt>
--   satisfies <tt>p</tt>. Represents the "exists" quantifier over a given
--   universe.
--   
--   This is mostly useful for its <a>Decidable</a> and <a>TFunctor</a>
--   instances, which lets you lift predicates on <tt>p</tt> to predicates
--   on <tt><a>Any</a> f p</tt>.
data Any f :: (k ~> Type) -> (f k ~> Type)

-- | A <tt><a>WitAny</a> p as</tt> is a witness that, for at least one item
--   <tt>a</tt> in the type-level collection <tt>as</tt>, the predicate
--   <tt>p a</tt> is true.
data WitAny f :: (k ~> Type) -> f k -> Type
[WitAny] :: Elem f as a -> (p @@ a) -> WitAny f p as

-- | A <tt><a>None</a> f p</tt> is a predicate on a collection <tt>as</tt>
--   that no <tt>a</tt> in <tt>as</tt> satisfies predicate <tt>p</tt>.
type None f p = (Not (Any f p) :: Predicate (f k))

-- | If there exists an <tt>a</tt> s.t. <tt>p a</tt>, and if <tt>p</tt>
--   implies <tt>q</tt>, then there must exist an <tt>a</tt> s.t. <tt>q
--   a</tt>.
entailAny :: forall f p q. Universe f => (p --> q) -> Any f p --> Any f q

-- | <a>entailAny</a>, but providing an <a>Elem</a>.
ientailAny :: forall f p q as. (Universe f, SingI as) => (forall a. Elem f as a -> Sing a -> (p @@ a) -> q @@ a) -> (Any f p @@ as) -> Any f q @@ as

-- | If <tt>p</tt> implies <tt>q</tt> under some context <tt>h</tt>, and if
--   there exists some <tt>a</tt> such that <tt>p a</tt>, then there must
--   exist some <tt>a</tt> such that <tt>p q</tt> under that context
--   <tt>h</tt>.
--   
--   <tt>h</tt> might be something like, say, <a>Maybe</a>, to give
--   predicate that is either provably true or unprovably false.
--   
--   Note that it is not possible to do this with <tt>p a -&gt;
--   <a>Decision</a> (q a)</tt>. This is if the <tt>p a -&gt;
--   <a>Decision</a> (q a)</tt> implication is false, there it doesn't mean
--   that there is <i>no</i> <tt>a</tt> such that <tt>q a</tt>,
--   necessarily. There could have been an <tt>a</tt> where <tt>p</tt> does
--   not hold, but <tt>q</tt> does.
entailAnyF :: forall f p q h. (Universe f, Functor h) => (p --># q) h -> (Any f p --># Any f q) h

-- | <a>entailAnyF</a>, but providing an <a>Elem</a>.
ientailAnyF :: forall f p q as h. Functor h => (forall a. Elem f as a -> (p @@ a) -> h (q @@ a)) -> (Any f p @@ as) -> h (Any f q @@ as)

-- | An <tt><a>All</a> f p</tt> is a predicate testing a collection <tt>as
--   :: f a</tt> for the fact that <i>all</i> items in <tt>as</tt> satisfy
--   <tt>p</tt>. Represents the "forall" quantifier over a given universe.
--   
--   This is mostly useful for its <a>Decidable</a>, <a>Provable</a>, and
--   <a>TFunctor</a> instances, which lets you lift predicates on
--   <tt>p</tt> to predicates on <tt><a>All</a> f p</tt>.
data All f :: (k ~> Type) -> (f k ~> Type)

-- | A <tt><a>WitAll</a> p as</tt> is a witness that the predicate <tt>p
--   a</tt> is true for all items <tt>a</tt> in the type-level collection
--   <tt>as</tt>.
newtype WitAll f p (as :: f k)
WitAll :: (forall a. Elem f as a -> p @@ a) -> WitAll f p
[runWitAll] :: WitAll f p -> forall a. Elem f as a -> p @@ a

-- | If for all <tt>a</tt> we have <tt>p a</tt>, and if <tt>p</tt> implies
--   <tt>q</tt>, then for all <tt>a</tt> we must also have <tt>p a</tt>.
entailAll :: forall f p q. Universe f => (p --> q) -> All f p --> All f q

-- | <a>entailAll</a>, but providing an <a>Elem</a>.
ientailAll :: forall f p q as. (Universe f, SingI as) => (forall a. Elem f as a -> Sing a -> (p @@ a) -> q @@ a) -> (All f p @@ as) -> All f q @@ as

-- | If <tt>p</tt> implies <tt>q</tt> under some context <tt>h</tt>, and if
--   we have <tt>p a</tt> for all <tt>a</tt>, then we must have <tt>q
--   a</tt> for all <tt>a</tt> under context <tt>h</tt>.
entailAllF :: forall f p q h. (Universe f, Applicative h) => (p --># q) h -> (All f p --># All f q) h

-- | <a>entailAllF</a>, but providing an <a>Elem</a>.
ientailAllF :: forall f p q as h. (Universe f, Applicative h, SingI as) => (forall a. Elem f as a -> (p @@ a) -> h (q @@ a)) -> (All f p @@ as) -> h (All f q @@ as)

-- | If we have <tt>p a</tt> for all <tt>a</tt>, and <tt>p a</tt> can be
--   used to test for <tt>q a</tt>, then we can test all <tt>a</tt>s for
--   <tt>q a</tt>.
decideEntailAll :: forall f p q. Universe f => (p -?> q) -> All f p -?> All f q

-- | <a>entailAllF</a>, but providing an <a>Elem</a>.
idecideEntailAll :: forall f p q as. (Universe f, SingI as) => (forall a. Elem f as a -> (p @@ a) -> Decision (q @@ a)) -> (All f p @@ as) -> Decision (All f q @@ as)


-- | Manipulate "parameterized predicates". See <a>ParamPred</a> and
--   <a>Found</a> for more information.
module Data.Type.Predicate.Param

-- | A parameterized predicate. See <a>Found</a> for more information.
type ParamPred k v = k -> Predicate v

-- | Flip the arguments of a <a>ParamPred</a>.
data FlipPP :: ParamPred v k -> ParamPred k v

-- | Promote a <tt><a>Predicate</a> v</tt> to a <tt><a>ParamPred</a> k
--   v</tt>, ignoring the <tt>k</tt> input.
data ConstPP :: Predicate v -> ParamPred k v

-- | Pre-compose a function to a <a>ParamPred</a>. Is essentially
--   <tt><a>flip</a> (<a>.</a>)</tt>, but unfortunately defunctionalization
--   doesn't work too well with that definition.
data PPMap :: (k ~> j) -> ParamPred j v -> ParamPred k v

-- | A <tt><a>ParamPred</a> (f k) k</tt>. Parameterized on an <tt>as :: f
--   k</tt>, returns a predicate that is true if there exists any <tt>a ::
--   k</tt> in <tt>as</tt>.
--   
--   Essentially <a>NotNull</a>.
type InP f = (ElemSym1 f :: ParamPred (f k) k)

-- | <tt><a>AnyMatch</a> f</tt> takes a parmaeterized predicate on
--   <tt>k</tt> (testing for a <tt>v</tt>) and turns it into a
--   parameterized predicate on <tt>f k</tt> (testing for a <tt>v</tt>). It
--   "lifts" the domain into <tt>f</tt>.
--   
--   An <tt><a>AnyMatch</a> f p as</tt> is a predicate taking an argument
--   <tt>a</tt> and testing if <tt>p a :: <a>Predicate</a> k</tt> is
--   satisfied for any item in <tt>as :: f k</tt>.
--   
--   A <tt><a>ParamPred</a> k v</tt> tests if a <tt>k</tt> can create some
--   <tt>v</tt>. The resulting <tt><a>ParamPred</a> (f k) v</tt> tests if
--   any <tt>k</tt> in <tt>f k</tt> can create some <tt>v</tt>.
data AnyMatch f :: ParamPred k v -> ParamPred (f k) v

-- | Convert a parameterized predicate into a predicate on the parameter.
--   
--   A <tt><a>Found</a> p</tt> is a predicate on <tt>p :: <a>ParamPred</a>
--   k v</tt> that tests a <tt>k</tt> for the fact that there exists a
--   <tt>v</tt> where <tt><a>ParamPred</a> k v</tt> is satisfied.
--   
--   Intended as the basic interface for <a>ParamPred</a>, since it turns a
--   <a>ParamPred</a> into a normal <a>Predicate</a>, which can have
--   <a>Decidable</a> and <a>Provable</a> instances.
--   
--   For some context, an instance of <tt><a>Provable</a> (<a>Found</a>
--   P)</tt>, where <tt>P :: <a>ParamPred</a> k v</tt>, means that for any
--   input <tt>x :: k</tt>, we can always find a <tt>y :: v</tt> such that
--   we have <tt>P x </tt><tt> y</tt>.
--   
--   In the language of quantifiers, it means that forall <tt>x :: k</tt>,
--   there exists a <tt>y :: v</tt> such that <tt>P x </tt><tt> y</tt>.
--   
--   For an instance of <tt><a>Decidable</a> (<a>Found</a> P)</tt>, it
--   means that for all <tt>x :: k</tt>, we can prove or disprove the fact
--   that there exists a <tt>y :: v</tt> such that <tt>P x </tt><tt>
--   y</tt>.
data Found :: ParamPred k v -> Predicate k

-- | Convenient alias for <a>decide</a> in the case of <tt><a>Found</a>
--   p</tt>; basically like <a>decide</a> for a <a>ParamPred</a>. Saying
--   that predicate <tt><a>Found</a> p</tt> is decidable means that, for an
--   input <tt>x :: k</tt>, we can prove or disprove that there exists a
--   <tt>y :: v</tt> that satisfies <tt>P x </tt><tt> y</tt>.
--   
--   Can be called by applying the <a>ParamPred</a>:
--   
--   <pre>
--   <a>search</a> @p
--   </pre>
search :: forall p. Decidable (Found p) => Decide (Found p)

-- | Convenient alias for <a>prove</a> in the case of <tt><a>Found</a>
--   p</tt>; basically like <a>prove</a> for <a>ParamPred</a>. You can
--   imagine it as generating the witness for "forall <tt>x :: k</tt>.
--   exists <tt>y :: v</tt>. P x @@ y".
--   
--   Can be called by applying the <a>ParamPred</a>:
--   
--   <pre>
--   <a>select</a> @p
--   </pre>
select :: forall p. Provable (Found p) => Prove (Found p)
instance forall k v (f :: * -> *) (p :: Data.Type.Predicate.Param.ParamPred k v). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found p)) => Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found (Data.Type.Predicate.Param.AnyMatch f p))
instance Data.Type.Universe.Universe f => Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found (Data.Type.Predicate.Param.InP f))
instance Data.Type.Predicate.Decidable (Data.Type.Universe.NotNull f Data.Type.Predicate.Logic.==> Data.Type.Predicate.Param.Found (Data.Type.Predicate.Param.InP f))
instance Data.Type.Predicate.Provable (Data.Type.Universe.NotNull f Data.Type.Predicate.Logic.==> Data.Type.Predicate.Param.Found (Data.Type.Predicate.Param.InP f))
instance Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found (Data.Type.Predicate.Param.InP f) Data.Type.Predicate.Logic.==> Data.Type.Universe.NotNull f)
instance Data.Type.Predicate.Provable (Data.Type.Predicate.Param.Found (Data.Type.Predicate.Param.InP f) Data.Type.Predicate.Logic.==> Data.Type.Universe.NotNull f)
instance forall j v k (p :: Data.Type.Predicate.Param.ParamPred j v) (f :: k Data.Singletons.Internal.~> j). (Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found p), Data.Singletons.Internal.SingI f) => Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found (Data.Type.Predicate.Param.PPMap f p))
instance forall j v k (p :: Data.Type.Predicate.Param.ParamPred j v) (f :: k Data.Singletons.Internal.~> j). (Data.Type.Predicate.Provable (Data.Type.Predicate.Param.Found p), Data.Singletons.Internal.SingI f) => Data.Type.Predicate.Provable (Data.Type.Predicate.Param.Found (Data.Type.Predicate.Param.PPMap f p))


-- | Represent a decidable subset of a type-level collection.
module Data.Type.Universe.Subset

-- | A <tt><a>Subset</a> f p</tt> is a predicate that some decidable subset
--   of an input <tt>as</tt> is true.
data Subset f :: (k ~> Type) -> (f k ~> Type)

-- | A <tt><a>WitSubset</a> f p </tt><tt> as</tt> describes a
--   <i>decidable</i> subset of type-level collection <tt>as</tt>.
newtype WitSubset f p (as :: f k)
WitSubset :: (forall a. Elem f as a -> Decision (p @@ a)) -> WitSubset f p
[runWitSubset] :: WitSubset f p -> forall a. Elem f as a -> Decision (p @@ a)

-- | Create a <a>Subset</a> from a predicate.
makeSubset :: forall f k p (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> Sing as -> Subset f p @@ as

-- | Subset intersection
intersection :: forall f p q. () => (Subset f p &&& Subset f q) --> Subset f (p &&& q)

-- | Subset union
union :: forall f p q. () => (Subset f p &&& Subset f q) --> Subset f (p ||| q)

-- | Symmetric subset difference
symDiff :: forall f p q. () => (Subset f p &&& Subset f q) --> Subset f (p ^^^ q)

-- | Combine two subsets based on a decision function
mergeSubset :: forall f k p q r (as :: f k). () => (forall a. Decision (p @@ a) -> Decision (q @@ a) -> Decision (r @@ a)) -> (Subset f p @@ as) -> (Subset f q @@ as) -> Subset f r @@ as

-- | Combine two subsets based on a decision function
imergeSubset :: forall f k p q r (as :: f k). () => (forall a. Elem f as a -> Decision (p @@ a) -> Decision (q @@ a) -> Decision (r @@ a)) -> (Subset f p @@ as) -> (Subset f q @@ as) -> Subset f r @@ as

-- | Turn a <a>Subset</a> into a list (or any <a>Alternative</a>) of
--   satisfied predicates.
subsetToList :: forall f p t. (Universe f, Alternative t) => (Subset f p --># Any f p) t

-- | Restrict a <a>Subset</a> to a single (arbitrary) member, or fail if
--   none exists.
subsetToAny :: forall f p. Universe f => Subset f p -?> Any f p

-- | Test if a subset is equal to the entire original collection
subsetToAll :: forall f p. Universe f => Subset f p -?> All f p
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decidable p) => Data.Type.Predicate.Decidable (Data.Type.Universe.Subset.Subset f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decidable p) => Data.Type.Predicate.Provable (Data.Type.Universe.Subset.Subset f p)
