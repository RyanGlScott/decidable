-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for manipulating dependently-typed predicates.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/mstksg/decidable-predicates#readme</a>
@package decidable-predicates
@version 0.1.0.0

module Data.Type.Predicate
type Predicate k = k ~> Type
newtype Wit p a
Wit :: p @@ a -> Wit p a
[getWit] :: Wit p a -> p @@ a

-- | Convert a normal '-&gt;' type constructor into a <a>Predicate</a>.
--   
--   <pre>
--   <a>TyPred</a> :: (k -&gt; <a>Type</a>) -&gt; <a>Predicate</a> k
--   </pre>
type TyPred = TyCon1

-- | The always-true predicate.
--   
--   <pre>
--   <a>Evident</a> :: Predicate k
--   </pre>
type Evident = TyPred Sing
type EqualTo a = TyCon1 ((:~:) a)

-- | Convert a propositional predicate into a <a>Predicate</a>
--   
--   <pre>
--   <a>BoolPred</a> :: (k ~&gt; Bool) -&gt; Predicate k
--   </pre>
type BoolPred p = EqualTo  'True .@#@$$$ p

-- | Convert a <i>parameterized</i> predicate, yield a predicate on the
--   parameter.
data Found :: (k -> Predicate v) -> Predicate k
data Not :: (k ~> Type) -> (k ~> Type)
proveNot :: forall p a. () => Decision (p @@ a) -> Decision (Not p @@ a)
data (&&&) :: (k ~> Type) -> (k ~> Type) -> (k ~> Type)
proveAnd :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p &&& q) @@ a)
data (|||) :: (k ~> Type) -> (k ~> Type) -> (k ~> Type)
proveOr :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p ||| q) @@ a)
type p ^^^ q = (p &&& Not q) ||| (Not p &&& q)
proveXor :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p ^^^ q) @@ a)
type Test p = forall a. Sing a -> Decision (p @@ a)
type p -?> q = forall a. Sing a -> p @@ a -> Decision (q @@ a)
type ( p -?># q ) h = forall a. Sing a -> p @@ a -> h (Decision (q @@ a))
type Given p = forall a. Sing a -> p @@ a
type p --> q = forall a. Sing a -> p @@ a -> q @@ a
type ( p --># q ) h = forall a. Sing a -> p @@ a -> h (q @@ a)
class Decide p
decide :: Decide p => Test p
decide :: (Decide p, Taken p) => Test p
class Decide p => Taken p
taken :: Taken p => Given p
class DFunctor f
dmap :: forall p q. DFunctor f => (p -?> q) -> (f p -?> f q)
class TFunctor f
tmap :: forall p q. TFunctor f => (p --> q) -> (f p --> f q)
compImpl :: forall p q r. () => p --> q -> q --> r -> p --> r
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *) (q :: k1 Data.Singletons.Internal.~> *). (Data.Type.Predicate.Decide p, Data.Type.Predicate.Decide q) => Data.Type.Predicate.Decide (p Data.Type.Predicate.||| q)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *) (q :: k1 Data.Singletons.Internal.~> *). (Data.Type.Predicate.Decide p, Data.Type.Predicate.Decide q) => Data.Type.Predicate.Decide (p Data.Type.Predicate.&&& q)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *). Data.Type.Predicate.Decide p => Data.Type.Predicate.Decide (Data.Type.Predicate.Not p)
instance forall k (a :: k). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI a) => Data.Type.Predicate.Decide (Data.Type.Predicate.EqualTo a)
instance Data.Type.Predicate.Decide Data.Type.Predicate.Evident
instance Data.Type.Predicate.Taken Data.Type.Predicate.Evident

module Data.Type.Universe

-- | A witness for membership of a given item in a type-level collection

-- | Typeclass for a type-level container that you can quantify or lift
--   type-level predicates over.
class Universe (f :: Type -> Type)

-- | You should read this type as:
--   
--   <pre>
--   <tt>decideAny'</tt> :: (<a>Sing</a> a  -&gt; <a>Decision</a> (p a)    )
--              -&gt; (Sing as -&gt; Decision (Any p as)
--   </pre>
--   
--   It lifts a predicate <tt>p</tt> on an individual <tt>a</tt> into a
--   predicate that on a collection <tt>as</tt> that is true if and only if
--   <i>any</i> item in <tt>as</tt> satisfies the original predicate.
--   
--   That is, it turns a predicate of kind <tt>k ~&gt; Type</tt> into a
--   predicate of kind <tt>f k ~&gt; Type</tt>.
--   
--   Essentially tests existential quantification.
idecideAny :: forall k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> (Sing as -> Decision (Any f p @@ as))

-- | You should read this type as:
--   
--   <pre>
--   <tt>decideAll'</tt> :: (<a>Sing</a> a  -&gt; <a>Decision</a> (p a)    )
--              -&gt; (<a>Sing</a> as -&gt; <a>Decision</a> (All p as)
--   </pre>
--   
--   It lifts a predicate <tt>p</tt> on an individual <tt>a</tt> into a
--   predicate that on a collection <tt>as</tt> that is true if and only if
--   <i>all</i> items in <tt>as</tt> satisfies the original predicate.
--   
--   That is, it turns a predicate of kind <tt>k ~&gt; Type</tt> into a
--   predicate of kind <tt>f k ~&gt; Type</tt>.
--   
--   Essentially tests universal quantification.
idecideAll :: forall k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> (Sing as -> Decision (All f p @@ as))

-- | If <tt>p a</tt> is true for all values <tt>a</tt> in <tt>as</tt> under
--   some (Applicative) context <tt>h</tt>, then you can create an
--   <tt><a>All</a> p as</tt> under that Applicative context <tt>h</tt>.
--   
--   Can be useful with <a>Identity</a> (which is basically unwrapping and
--   wrapping <a>All</a>), or with <a>Maybe</a> (which can express
--   predicates that are either provably true or not provably false).
igenAllA :: forall k (p :: k ~> Type) (as :: f k) h. (Universe f, Applicative h) => (forall a. Elem f as a -> Sing a -> h (p @@ a)) -> (Sing as -> h (All f p @@ as))
decideAny :: forall f k (p :: k ~> Type). Universe f => Test p -> Test (Any f p)
decideAll :: forall f k (p :: k ~> Type). Universe f => Test p -> Test (All f p)

-- | <a>igenAllA</a>, but without the membership witness.
genAllA :: forall k (p :: k ~> Type) (as :: f k) h. (Universe f, Applicative h) => (forall a. Sing a -> h (p @@ a)) -> (Sing as -> h (All f p @@ as))
genAll :: forall f k (p :: k ~> Type). Universe f => Given p -> Given (All f p)

-- | If <tt>p a</tt> is true for all values <tt>a</tt> in <tt>as</tt>, then
--   we have <tt><a>All</a> p as</tt>. Basically witnesses the definition
--   of <a>All</a>.
igenAll :: forall f k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> p @@ a) -> (Sing as -> All f p @@ as)

-- | A <a>foldMap</a> over all items in a collection.
foldMapUni :: forall f k (as :: f k) m. (Universe f, Monoid m) => (forall (a :: k). Sing a -> m) -> Sing as -> m

-- | <a>foldMapUni</a> but with access to the index.
ifoldMapUni :: forall f k (as :: f k) m. (Universe f, Monoid m) => (forall a. Elem f as a -> Sing a -> m) -> Sing as -> m

-- | Extract the item from the container witnessed by the <a>Elem</a>
select :: forall f as a. Universe f => Elem f as a -> Sing as -> Sing a

-- | Automatically generate a witness for a member, if possible
pickElem :: forall f k (as :: f k) a. (Universe f, SingI as, SingI a, SDecide k) => Decision (Elem f as a)
data All f :: (k ~> Type) -> (f k ~> Type)

-- | An <tt><a>All</a> p as</tt> is a witness that, the predicate <tt>p
--   a</tt> is true for all items <tt>a</tt> in the type-level collection
--   <tt>as</tt>.
newtype WitAll f p (as :: f k)
WitAll :: forall a. Elem f as a -> p @@ a -> WitAll f p
[runWitAll] :: WitAll f p -> forall a. Elem f as a -> p @@ a
data Any f :: (k ~> Type) -> (f k ~> Type)

-- | An <tt><a>Any</a> p as</tt> is a witness that, for at least one item
--   <tt>a</tt> in the type-level collection <tt>as</tt>, the predicate
--   <tt>p a</tt> is true.
data WitAny f :: (k ~> Type) -> f k -> Type
[WitAny] :: Elem f as a -> p @@ a -> WitAny f p as

-- | Witness an item in a type-level list by providing its index.
data Index :: [k] -> k -> Type
[IZ] :: Index (a : as) a
[IS] :: Index bs a -> Index (b : bs) a

-- | Witness an item in a type-level <a>Maybe</a> by proving the
--   <a>Maybe</a> is <a>Just</a>.
data IsJust :: Maybe k -> k -> Type
[IsJust] :: IsJust ( 'Just a) a

-- | Witness an item in a type-level <tt><a>Either</a> j</tt> by proving
--   the <a>Either</a> is <a>Right</a>.
data IsRight :: Either j k -> k -> Type
[IsRight] :: IsRight ( 'Right a) a

-- | Witness an item in a type-level <a>NonEmpty</a> by either indicating
--   that it is the "head", or by providing an index in the "tail".
data NEIndex :: NonEmpty k -> k -> Type
[NEHead] :: NEIndex (a :| as) a
[NETail] :: Index as a -> NEIndex (b :| as) a

-- | Trivially witness an item in the second field of a type-level tuple.
data Snd :: (j, k) -> k -> Type
[Snd] :: Snd '(a, b) b
instance forall k (as :: [k]) (a :: k). GHC.Show.Show (Data.Type.Universe.Index as a)
instance forall k (as :: GHC.Base.Maybe k) (a :: k). GHC.Show.Show (Data.Type.Universe.IsJust as a)
instance forall j k (as :: Data.Either.Either j k) (a :: k). GHC.Show.Show (Data.Type.Universe.IsRight as a)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k). GHC.Show.Show (Data.Type.Universe.NEIndex as a)
instance forall j k (as :: (j, k)) (a :: k). GHC.Show.Show (Data.Type.Universe.Snd as a)
instance forall j k (as :: (j, k)). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Type.Predicate.TyPred (Data.Type.Universe.Snd as))
instance Data.Type.Universe.Universe ((,) j)
instance forall k (as :: GHC.Base.NonEmpty k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Type.Predicate.TyPred (Data.Type.Universe.NEIndex as))
instance Data.Type.Universe.Universe GHC.Base.NonEmpty
instance forall j k (as :: Data.Either.Either j k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Type.Predicate.TyPred (Data.Type.Universe.IsRight as))
instance Data.Type.Universe.Universe (Data.Either.Either j)
instance forall k (as :: GHC.Base.Maybe k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Type.Predicate.TyPred (Data.Type.Universe.IsJust as))
instance Data.Type.Universe.Universe GHC.Base.Maybe
instance forall k (as :: [k]). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Type.Predicate.TyPred (Data.Type.Universe.Index as))
instance Data.Type.Universe.Universe []
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decide p) => Data.Type.Predicate.Decide (Data.Type.Universe.Any f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decide p) => Data.Type.Predicate.Decide (Data.Type.Universe.All f p)
instance Data.Type.Universe.Universe f => Data.Type.Predicate.TFunctor (Data.Type.Universe.Any f)
instance Data.Type.Universe.Universe f => Data.Type.Predicate.TFunctor (Data.Type.Universe.All f)
instance Data.Type.Universe.Universe f => Data.Type.Predicate.DFunctor (Data.Type.Universe.All f)

module Data.Type.Subset
data Subset f :: (k ~> Type) -> (f k ~> Type)

-- | A <tt><a>Subset</a> p as</tt> describes a <i>decidable</i> subset of
--   type-level collection <tt>as</tt>.
newtype WitSubset f p (as :: f k)
WitSubset :: forall a. Elem f as a -> Decision (p @@ a) -> WitSubset f p
[runWitSubset] :: WitSubset f p -> forall a. Elem f as a -> Decision (p @@ a)

-- | Create a <a>Subset</a> from a predicate.
makeSubset :: forall f k p (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> Sing as -> Subset f p @@ as

-- | Turn a <a>Subset</a> into a list (or any <a>Alternative</a>) of
--   satisfied predicates.
subsetToList :: forall f p t. (Universe f, Alternative t) => (Subset f p --># Any f p) t

-- | Restrict a <a>Subset</a> to a single (arbitrary) member, or fail if
--   none exists.
subsetToAny :: forall f p. Universe f => Subset f p -?> Any f p

-- | Test if a subset is equal to the entire original collection
subsetToAll :: forall f p. Universe f => Subset f p -?> All f p

-- | Subset intersection
intersection :: forall f p q. () => ((Subset f p &&& Subset f q) --> Subset f (p &&& q))

-- | Subset union
union :: forall f p q. () => ((Subset f p &&& Subset f q) --> Subset f (p ||| q))
symDiff :: forall f p q. () => ((Subset f p &&& Subset f q) --> Subset f (p ^^^ q))

-- | Combine two subsets based on a decision function
mergeSubset :: forall f k p q r (as :: f k). () => (forall a. Decision (p @@ a) -> Decision (q @@ a) -> Decision (r @@ a)) -> Subset f p @@ as -> Subset f q @@ as -> Subset f r @@ as

-- | Combine two subsets based on a decision function
imergeSubset :: forall f k p q r (as :: f k). () => (forall a. Elem f as a -> Decision (p @@ a) -> Decision (q @@ a) -> Decision (r @@ a)) -> Subset f p @@ as -> Subset f q @@ as -> Subset f r @@ as
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decide p) => Data.Type.Predicate.Decide (Data.Type.Subset.Subset f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decide p) => Data.Type.Predicate.Taken (Data.Type.Subset.Subset f p)

module Data.Type.Quantification
data Any f :: (k ~> Type) -> (f k ~> Type)

-- | An <tt><a>Any</a> p as</tt> is a witness that, for at least one item
--   <tt>a</tt> in the type-level collection <tt>as</tt>, the predicate
--   <tt>p a</tt> is true.
data WitAny f :: (k ~> Type) -> f k -> Type
[WitAny] :: Elem f as a -> p @@ a -> WitAny f p as
entailAny :: forall f p q. Universe f => (p --> q) -> (Any f p --> Any f q)

-- | If there exists an <tt>a</tt> s.t. <tt>p a</tt>, and if <tt>p</tt>
--   implies <tt>q</tt>, then there must exist an <tt>a</tt> s.t. <tt>q
--   a</tt>.
ientailAny :: forall f p q as. (Universe f, SingI as) => (forall a. Elem f as a -> Sing a -> p @@ a -> q @@ a) -> Any f p @@ as -> Any f q @@ as

-- | <a>entailAnyF</a>, but without the membership witness.
entailAnyF :: forall f p q h. (Universe f, Functor h) => (p --># q) h -> (Any f p --># Any f q) h

-- | If <tt>p</tt> implies <tt>q</tt> under some context <tt>h</tt>, and if
--   there exists some <tt>a</tt> such that <tt>p a</tt>, then there must
--   exist some <tt>a</tt> such that <tt>p q</tt> under that context
--   <tt>h</tt>.
--   
--   <tt>h</tt> might be something like, say, <a>Maybe</a>, to give
--   predicate that is either provably true or unprovably false.
--   
--   Note that it is not possible to do this with <tt>p a -&gt;
--   <a>Decision</a> (q a)</tt>. This is if the <tt>p a -&gt;
--   <a>Decision</a> (q a)</tt> implication is false, there it doesn't mean
--   that there is <i>no</i> <tt>a</tt> such that <tt>q a</tt>,
--   necessarily. There could have been an <tt>a</tt> where <tt>p</tt> does
--   not hold, but <tt>q</tt> does.
ientailAnyF :: forall f p q as h. Functor h => (forall a. Elem f as a -> p @@ a -> h (q @@ a)) -> Any f p @@ as -> h (Any f q @@ as)
data All f :: (k ~> Type) -> (f k ~> Type)

-- | An <tt><a>All</a> p as</tt> is a witness that, the predicate <tt>p
--   a</tt> is true for all items <tt>a</tt> in the type-level collection
--   <tt>as</tt>.
newtype WitAll f p (as :: f k)
WitAll :: forall a. Elem f as a -> p @@ a -> WitAll f p
[runWitAll] :: WitAll f p -> forall a. Elem f as a -> p @@ a
entailAll :: forall f p q. Universe f => (p --> q) -> (All f p --> All f q)

-- | If for all <tt>a</tt> we have <tt>p a</tt>, and if <tt>p</tt> implies
--   <tt>q</tt>, then for all <tt>a</tt> we must also have <tt>p a</tt>.
ientailAll :: forall f p q as. (Universe f, SingI as) => (forall a. Elem f as a -> Sing a -> p @@ a -> q @@ a) -> All f p @@ as -> All f q @@ as

-- | <a>entailAllF</a>, but without the membership witness.
entailAllF :: forall f p q h. (Universe f, Applicative h) => (p --># q) h -> (All f p --># All f q) h

-- | If <tt>p</tt> implies <tt>q</tt> under some context <tt>h</tt>, and if
--   we have <tt>p a</tt> for all <tt>a</tt>, then we must have <tt>q
--   a</tt> for all <tt>a</tt> under context <tt>h</tt>.
ientailAllF :: forall f p q as h. (Universe f, Applicative h, SingI as) => (forall a. Elem f as a -> p @@ a -> h (q @@ a)) -> All f p @@ as -> h (All f q @@ as)

-- | <a>decideEntailAll</a>, but without the membeship witness.
decideEntailAll :: forall f p q. Universe f => p -?> q -> All f p -?> All f q

-- | If we have <tt>p a</tt> for all <tt>a</tt>, and <tt>p a</tt> can be
--   used to test for <tt>q a</tt>, then we can test all <tt>a</tt>s for
--   <tt>q a</tt>.
idecideEntailAll :: forall f p q as. (Universe f, SingI as) => (forall a. Elem f as a -> p @@ a -> Decision (q @@ a)) -> All f p @@ as -> Decision (All f q @@ as)
