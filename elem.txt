-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Class and combinators for expressing membership in type-level containers
--   
--   Please see the README on GitHub at
--   <a>https://github.com/mstksg/elem#readme</a>
@package elem
@version 0.1.0.0

module Data.Type.Predicate
type Predicate k = k ~> Type
newtype Wit p a
Wit :: p @@ a -> Wit p a
[getWit] :: Wit p a -> p @@ a
type Test p = forall a. Sing a -> Decision (p @@ a)
type p -?> q = forall a. Sing a -> p @@ a -> Decision (q @@ a)
type ( p -?># q ) h = forall a. Sing a -> p @@ a -> h (Decision (q @@ a))
type Given p = forall a. Sing a -> p @@ a
type p --> q = forall a. Sing a -> p @@ a -> q @@ a
type ( p --># q ) h = forall a. Sing a -> p @@ a -> h (q @@ a)
class Decide p
decide :: Decide p => Test p
decide :: (Decide p, Taken p) => Test p
class Decide p => Taken p
taken :: Taken p => Given p
data Not :: (k ~> Type) -> (k ~> Type)
proveNot :: forall p a. () => Decision (p @@ a) -> Decision (Not p @@ a)
data (&&&) :: (k ~> Type) -> (k ~> Type) -> (k ~> Type)
proveAnd :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p &&& q) @@ a)
data (|||) :: (k ~> Type) -> (k ~> Type) -> (k ~> Type)
proveOr :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p ||| q) @@ a)
type p ^^^ q = (p &&& Not q) ||| (Not p &&& q)
proveXor :: forall p q a. () => Decision (p @@ a) -> Decision (q @@ a) -> Decision ((p ^^^ q) @@ a)
compImpl :: forall p q r. () => p --> q -> q --> r -> p --> r
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *) (q :: k1 Data.Singletons.Internal.~> *). (Data.Type.Predicate.Decide p, Data.Type.Predicate.Decide q) => Data.Type.Predicate.Decide (p Data.Type.Predicate.||| q)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *) (q :: k1 Data.Singletons.Internal.~> *). (Data.Type.Predicate.Decide p, Data.Type.Predicate.Decide q) => Data.Type.Predicate.Decide (p Data.Type.Predicate.&&& q)
instance forall k1 (p :: k1 Data.Singletons.Internal.~> *). Data.Type.Predicate.Decide p => Data.Type.Predicate.Decide (Data.Type.Predicate.Not p)
instance forall k (a :: k). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI a) => Data.Type.Predicate.Decide (Data.Singletons.Internal.TyCon1 ((Data.Type.Equality.:~:) a))
instance Data.Type.Predicate.Decide (Data.Singletons.Internal.TyCon1 Data.Singletons.Internal.Sing)
instance Data.Type.Predicate.Taken (Data.Singletons.Internal.TyCon1 Data.Singletons.Internal.Sing)

module Data.Type.Universe

-- | A witness for membership of a given item in a type-level collection

-- | Typeclass for a type-level container that you can quantify or lift
--   type-level predicates over.
class Universe (f :: Type -> Type)

-- | You should read this type as:
--   
--   <pre>
--   <tt>decideAny'</tt> :: (<a>Sing</a> a  -&gt; <a>Decision</a> (p a)    )
--              -&gt; (Sing as -&gt; Decision (Any p as)
--   </pre>
--   
--   It lifts a predicate <tt>p</tt> on an individual <tt>a</tt> into a
--   predicate that on a collection <tt>as</tt> that is true if and only if
--   <i>any</i> item in <tt>as</tt> satisfies the original predicate.
--   
--   That is, it turns a predicate of kind <tt>k ~&gt; Type</tt> into a
--   predicate of kind <tt>f k ~&gt; Type</tt>.
--   
--   Essentially tests existential quantification.
idecideAny :: forall k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> (Sing as -> Decision (Any f p as))

-- | You should read this type as:
--   
--   <pre>
--   <tt>decideAll'</tt> :: (<a>Sing</a> a  -&gt; <a>Decision</a> (p a)    )
--              -&gt; (<a>Sing</a> as -&gt; <a>Decision</a> (All p as)
--   </pre>
--   
--   It lifts a predicate <tt>p</tt> on an individual <tt>a</tt> into a
--   predicate that on a collection <tt>as</tt> that is true if and only if
--   <i>all</i> items in <tt>as</tt> satisfies the original predicate.
--   
--   That is, it turns a predicate of kind <tt>k ~&gt; Type</tt> into a
--   predicate of kind <tt>f k ~&gt; Type</tt>.
--   
--   Essentially tests universal quantification.
idecideAll :: forall k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> (Sing as -> Decision (All f p as))

-- | If <tt>p a</tt> is true for all values <tt>a</tt> in <tt>as</tt> under
--   some (Applicative) context <tt>h</tt>, then you can create an
--   <tt><a>All</a> p as</tt> under that Applicative context <tt>h</tt>.
--   
--   Can be useful with <a>Identity</a> (which is basically unwrapping and
--   wrapping <a>All</a>), or with <a>Maybe</a> (which can express
--   predicates that are either provably true or not provably false).
igenAllA :: forall k (p :: k ~> Type) (as :: f k) h. (Universe f, Applicative h) => (forall a. Elem f as a -> Sing a -> h (p @@ a)) -> (Sing as -> h (All f p as))
decideAny :: forall f k (p :: k ~> Type). Universe f => Test p -> Test (AnyPred f p)
decideAll :: forall f k (p :: k ~> Type). Universe f => Test p -> Test (AllPred f p)

-- | <a>igenAllA</a>, but without the membership witness.
genAllA :: forall k (p :: k ~> Type) (as :: f k) h. (Universe f, Applicative h) => (forall a. Sing a -> h (p @@ a)) -> (Sing as -> h (All f p as))
genAll :: forall f k (p :: k ~> Type). Universe f => Given p -> Given (AllPred f p)

-- | If <tt>p a</tt> is true for all values <tt>a</tt> in <tt>as</tt>, then
--   we have <tt><a>All</a> p as</tt>. Basically witnesses the definition
--   of <a>All</a>.
igenAll :: forall f k (p :: k ~> Type) (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> p @@ a) -> (Sing as -> All f p as)

-- | A <a>foldMap</a> over all items in a collection.
foldMapUni :: forall f k (as :: f k) m. (Universe f, SingI as, Monoid m) => (forall (a :: k). Sing a -> m) -> Sing as -> m

-- | <a>foldMapUni</a> but with access to the index.
ifoldMapUni :: forall f k (as :: f k) m. (Universe f, SingI as, Monoid m) => (forall a. Elem f as a -> Sing a -> m) -> Sing as -> m

-- | Extract the item from the container witnessed by the <a>Elem</a>
select :: forall f as a. Universe f => Elem f as a -> Sing as -> Sing a

-- | Automatically generate a witness for a member, if possible
pickElem :: forall f k (as :: f k) a. (Universe f, SingI as, SingI a, SDecide k) => Decision (Elem f as a)

-- | An <tt><a>All</a> p as</tt> is a witness that, the predicate <tt>p
--   a</tt> is true for all items <tt>a</tt> in the type-level collection
--   <tt>as</tt>.
newtype All f p (as :: f k)
All :: forall a. Elem f as a -> p @@ a -> All f p
[runAll] :: All f p -> forall a. Elem f as a -> p @@ a
data AllPred f :: (k ~> Type) -> (f k ~> Type)

-- | An <tt><a>Any</a> p as</tt> is a witness that, for at least one item
--   <tt>a</tt> in the type-level collection <tt>as</tt>, the predicate
--   <tt>p a</tt> is true.
data Any f :: (k ~> Type) -> f k -> Type
[Any] :: Elem f as a -> p @@ a -> Any f p as
data AnyPred f :: (k ~> Type) -> (f k ~> Type)

-- | Witness an item in a type-level list by providing its index.
data Index :: [k] -> k -> Type
[IZ] :: Index (a : as) a
[IS] :: Index bs a -> Index (b : bs) a

-- | Witness an item in a type-level <a>Maybe</a> by proving the
--   <a>Maybe</a> is <a>Just</a>.
data IsJust :: Maybe k -> k -> Type
[IsJust] :: IsJust ( 'Just a) a

-- | Witness an item in a type-level <tt><a>Either</a> j</tt> by proving
--   the <a>Either</a> is <a>Right</a>.
data IsRight :: Either j k -> k -> Type
[IsRight] :: IsRight ( 'Right a) a

-- | Witness an item in a type-level <a>NonEmpty</a> by either indicating
--   that it is the "head", or by providing an index in the "tail".
data NEIndex :: NonEmpty k -> k -> Type
[NEHead] :: NEIndex (a :| as) a
[NETail] :: Index as a -> NEIndex (b :| as) a

-- | Trivially witness an item in the second field of a type-level tuple.
data Snd :: (j, k) -> k -> Type
[Snd] :: Snd '(a, b) b
instance forall k (as :: [k]) (a :: k). GHC.Show.Show (Data.Type.Universe.Index as a)
instance forall k (as :: GHC.Base.Maybe k) (a :: k). GHC.Show.Show (Data.Type.Universe.IsJust as a)
instance forall j k (as :: Data.Either.Either j k) (a :: k). GHC.Show.Show (Data.Type.Universe.IsRight as a)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k). GHC.Show.Show (Data.Type.Universe.NEIndex as a)
instance forall j k (as :: (j, k)) (a :: k). GHC.Show.Show (Data.Type.Universe.Snd as a)
instance forall j k (as :: (j, k)). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Singletons.Internal.TyCon1 (Data.Type.Universe.Snd as))
instance Data.Type.Universe.Universe ((,) j)
instance forall k (as :: GHC.Base.NonEmpty k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Singletons.Internal.TyCon1 (Data.Type.Universe.NEIndex as))
instance Data.Type.Universe.Universe GHC.Base.NonEmpty
instance forall j k (as :: Data.Either.Either j k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Singletons.Internal.TyCon1 (Data.Type.Universe.IsRight as))
instance Data.Type.Universe.Universe (Data.Either.Either j)
instance forall k (as :: GHC.Base.Maybe k). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Singletons.Internal.TyCon1 (Data.Type.Universe.IsJust as))
instance Data.Type.Universe.Universe GHC.Base.Maybe
instance forall k (as :: [k]). (Data.Singletons.Internal.SingI as, Data.Singletons.Decide.SDecide k) => Data.Type.Predicate.Decide (Data.Singletons.Internal.TyCon1 (Data.Type.Universe.Index as))
instance Data.Type.Universe.Universe []
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decide p) => Data.Type.Predicate.Decide (Data.Type.Universe.AnyPred f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decide p) => Data.Type.Predicate.Decide (Data.Type.Universe.AllPred f p)

module Data.Type.Quantification

-- | An <tt><a>Any</a> p as</tt> is a witness that, for at least one item
--   <tt>a</tt> in the type-level collection <tt>as</tt>, the predicate
--   <tt>p a</tt> is true.
data Any f :: (k ~> Type) -> f k -> Type
[Any] :: Elem f as a -> p @@ a -> Any f p as
data AnyPred f :: (k ~> Type) -> (f k ~> Type)
entailAny :: Universe f => (p --> q) -> (AnyPred f p --> AnyPred f q)

-- | If there exists an <tt>a</tt> s.t. <tt>p a</tt>, and if <tt>p</tt>
--   implies <tt>q</tt>, then there must exist an <tt>a</tt> s.t. <tt>q
--   a</tt>.
ientailAny :: forall f p q as. () => (forall a. Elem f as a -> p @@ a -> q @@ a) -> Any f p as -> Any f q as

-- | <a>entailAnyF</a>, but without the membership witness.
entailAnyF :: forall f p q h. (Universe f, Functor h) => (p --># q) h -> (AnyPred f p --># AnyPred f q) h

-- | If <tt>p</tt> implies <tt>q</tt> under some context <tt>h</tt>, and if
--   there exists some <tt>a</tt> such that <tt>p a</tt>, then there must
--   exist some <tt>a</tt> such that <tt>p q</tt> under that context
--   <tt>h</tt>.
--   
--   <tt>h</tt> might be something like, say, <a>Maybe</a>, to give
--   predicate that is either provably true or unprovably false.
--   
--   Note that it is not possible to do this with <tt>p a -&gt;
--   <a>Decision</a> (q a)</tt>. This is if the <tt>p a -&gt;
--   <a>Decision</a> (q a)</tt> implication is false, there it doesn't mean
--   that there is <i>no</i> <tt>a</tt> such that <tt>q a</tt>,
--   necessarily. There could have been an <tt>a</tt> where <tt>p</tt> does
--   not hold, but <tt>q</tt> does.
ientailAnyF :: forall f p q as h. Functor h => (forall a. Elem f as a -> p @@ a -> h (q @@ a)) -> Any f p as -> h (Any f q as)

-- | An <tt><a>All</a> p as</tt> is a witness that, the predicate <tt>p
--   a</tt> is true for all items <tt>a</tt> in the type-level collection
--   <tt>as</tt>.
newtype All f p (as :: f k)
All :: forall a. Elem f as a -> p @@ a -> All f p
[runAll] :: All f p -> forall a. Elem f as a -> p @@ a
data AllPred f :: (k ~> Type) -> (f k ~> Type)
entailAll :: Universe f => (p --> q) -> (AllPred f p --> AllPred f q)

-- | If for all <tt>a</tt> we have <tt>p a</tt>, and if <tt>p</tt> implies
--   <tt>q</tt>, then for all <tt>a</tt> we must also have <tt>p a</tt>.
ientailAll :: forall f p q as. () => (forall a. Elem f as a -> p @@ a -> q @@ a) -> All f p as -> All f q as

-- | <a>entailAllF</a>, but without the membership witness.
entailAllF :: forall f p q h. (Universe f, Applicative h) => (p --># q) h -> (AllPred f p --># AllPred f q) h

-- | If <tt>p</tt> implies <tt>q</tt> under some context <tt>h</tt>, and if
--   we have <tt>p a</tt> for all <tt>a</tt>, then we must have <tt>q
--   a</tt> for all <tt>a</tt> under context <tt>h</tt>.
ientailAllF :: forall f p q as h. (Universe f, Applicative h, SingI as) => (forall a. Elem f as a -> p @@ a -> h (q @@ a)) -> All f p as -> h (All f q as)

-- | <a>decideEntailAll</a>, but without the membeship witness.
decideEntailAll :: forall f p q. Universe f => p -?> q -> AllPred f p -?> AllPred f q

-- | If we have <tt>p a</tt> for all <tt>a</tt>, and <tt>p a</tt> can be
--   used to test for <tt>q a</tt>, then we can test all <tt>a</tt>s for
--   <tt>q a</tt>.
idecideEntailAll :: forall f p q as. (Universe f, SingI as) => (forall a. Elem f as a -> p @@ a -> Decision (q @@ a)) -> All f p as -> Decision (All f q as)

-- | A <tt><a>Subset</a> p as</tt> describes a subset of type-level
--   collection <tt>as</tt>.
newtype Subset f p (as :: f k)
Subset :: forall a. Elem f as a -> Decision (p @@ a) -> Subset f p
[runSubset] :: Subset f p -> forall a. Elem f as a -> Decision (p @@ a)
data SubsetPred f :: (k ~> Type) -> (f k ~> Type)

-- | Create a <a>Subset</a> from a predicate.
makeSubset :: forall f k p (as :: f k). Universe f => (forall a. Elem f as a -> Sing a -> Decision (p @@ a)) -> Sing as -> Subset f p as

-- | Turn a <a>Subset</a> into a list of satisfied predicates.
subsetToList :: forall f k p (as :: f k). (Universe f, SingI as) => Subset f p as -> [Any f p as]

-- | Restrict a <a>Subset</a> to a single (arbitrary) member, or fail if
--   none exists.
subsetToAny :: forall f k p (as :: f k). (Universe f, SingI as) => Subset f p as -> Decision (Any f p as)

-- | Test if a subset is equal to the entire original collection
subsetToAll :: forall f k p (as :: f k). (Universe f, SingI as) => Subset f p as -> Decision (All f p as)

-- | Subset intersection
intersection :: forall f k p q (as :: f k). () => Subset f p as -> Subset f q as -> Subset f (p &&& q) as

-- | Subset union
union :: forall f k p q (as :: f k). () => Subset f p as -> Subset f q as -> Subset f (p ||| q) as

-- | Combine two subsets based on a decision function
mergeSubset :: forall f k p q r (as :: f k). () => (forall a. Elem f as a -> Decision (p @@ a) -> Decision (q @@ a) -> Decision (r @@ a)) -> Subset f p as -> Subset f q as -> Subset f r as
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decide p) => Data.Type.Predicate.Decide (Data.Type.Quantification.SubsetPred f p)
instance forall k (f :: * -> *) (p :: k Data.Singletons.Internal.~> *). (Data.Type.Universe.Universe f, Data.Type.Predicate.Decide p) => Data.Type.Predicate.Taken (Data.Type.Quantification.SubsetPred f p)
